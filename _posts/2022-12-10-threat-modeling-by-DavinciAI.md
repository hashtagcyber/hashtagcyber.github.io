---
layout: post
title: Threat Modelling Series - By DavinciAI
toc: true
---
# Threat Modeling Series - By DavinciAI

## Wait... whuuut?
ChatGPT is all the rage, but OpenAI has had an API for their Davinci AI model for a while now. I spent some time creating a docker container that:
- Prompts Davinci to write an outline of a book on a topic
- Iterates through each entry in the outline and asks Davinci to write a chapter about the the entry
- Saves the output as a markdown file.

It was a fun experiment, and in the future I think I'll spend some time training a model to write in "my voice" and use that to draft content. I'll still be editing it, \(and adding a disclaimer that it was generated by AI and edited by be\)... but it might make updates to this blog a bit more frequent :)

## Threat Modeling Article Links
Also note, I didn't do any real editing other than adding the disclaimer header. Some of the topics are redundant - and you'll see places where the bot decided to use "Chapter X" that don't fit with the rest of the formatting. That's ok... this was meant to be edited... but, IN THE NAME OF SCIENCE! \(and lack of time\) I didn't edit any of it.

- [Part 1](./2022-12-10-threat-modeling-part-1-introduction)
- [Part 2](./2022-12-10-threat-modeling-part-2-what-is-stridedread-hybrid-model)
- [Part 3](./2022-12-10-threat-modeling-part-3-what-are-the-benefits-of-using-the-stridedread-hybrid-model)
- [Part 4](./2022-12-10-threat-modeling-part-4-how-can-you-apply-the-stridedread-model-to-software-development)
- [Part 5](./2022-12-10-threat-modeling-part-5-identifying-threats-and-risks)
- [Part 6](./2022-12-10-threat-modeling-part-6-what-is-a-threat)
- [Part 7](./2022-12-10-threat-modeling-part-7-identifying-and-classifying-threats)
- [Part 8](./2022-12-10-threat-modeling-part-8-assessing-risk-impact-and-likelihoo)
- [Part 9](./2022-12-10-threat-modeling-part-9-developing-mitigations-with-the-stride-approach)
- [Part 10](./2022-12-10-threat-modeling-part-10-understanding-the-stride-framework)
- [Part 11](./2022-12-10-threat-modeling-part-11-identifying-spoofing-tampering-repudiation-information-disclosure-denial-of-service-and-elevation-of-privilege)
- [Part 12](./2022-12-10-threat-modeling-part-12-implementing-controls-with-the-dread-model)
- [Part 13](./2022-12-10-threat-modeling-part-13-understanding-the-dread-syste)
- [Part 14](./2022-12-10-threat-modeling-part-14-applying-damage-potential-reproducibility-exploitability-affected-users-and-discoverability-scoring-systems)
- [Part 15](./2022-12-10-threat-modeling-part-15-putting-it-all-together-building-security-into-software-development)
- [Part 16](./2022-12-10-threat-modeling-part-16-building-security-requirements-into-development-cycles)
- [Part 17](./2022-12-10-threat-modeling-part-17-defining-a-secure-development-lifecycle)
- [Part 18](./2022-12-10-threat-modeling-part-18-integrating-stridedread-into-the-testing-process)
- [Part 19](./2022-12-10-threat-modeling-part-19-summarizing-the-benefits-of-using-stridedread-model)
- [Part 20](./2022-12-10-threat-modeling-part-20-identifying-further-steps-for-securing-software-development)
- [Part 21](./2022-12-10-threat-modeling-part-21-conclusion)

## Getting Started
Note: OpenAI uses a "credit" system for billing. You get $18 of free credits when you sign up. During testing of my code, and generation of these 21 posts, I used $0.98 worth of my free credits. All in all - I think the pricing is fair :) 
---
1. Signup for an account at [openai.com](https://openai.com)
2. Generate an openai API key
3. Install the openai python library
4. Run some code like below...

## Code Snippet
```python3
import os
import openai
import keyring
import getpass
import argparse 
import datetime

def get_credentials():
    if os.environ.get('OPENAI_API_KEY') is None:
        token = keyring.get_password('openai','token')
    else:
        token = os.environ.get('OPENAI_API_KEY')
    if token is None:
        token = set_credentials()
    return token

def set_credentials():
    token = getpass.getpass('Enter your OpenAI API Key: ')
    keyring.set_password('openai','token', token)
    return token


def gen_idea_prompt(idea_string):
    idea_prompt = 'create the outline of a book that {}. The book should be informative and fun to read. '.format(idea_string)
    return idea_prompt

def gen_chapter_prompt(idea_prompt, chapter_title):
    blog_prompt_base = 'write a chapter for a book that {}. The subject of the chapter is {}. Format it using markdown. The book should be informative and entertaining.'
    blog_prompt = blog_prompt_base.format(idea_prompt, chapter_title)
    return blog_prompt

def get_ideas(idea_prompt):
    # OPENAI Code here, return a list of blog titles
    response = openai.Completion.create(
        model = 'text-davinci-003',
        prompt = idea_prompt,
        temperature= .9,
        max_tokens = 500,
        top_p=1,
        frequency_penalty=0.3,
        presence_penalty=0.0
    )
    return response

def get_blog(blog_prompt):
    # OPENAI Code here, return a string to be written as markdown file
    response = openai.Completion.create(
        model = 'text-davinci-003',
        prompt = blog_prompt,
        temperature= 1,
        max_tokens = 2000,
        top_p=1,
        frequency_penalty=0.3,
        presence_penalty=0.0
    )
    return response

def sanitize_title(blog_title):
    title = blog_title.lower().replace(' ','-')
    return ''.join(ch for ch in title if (ch.isalnum() or ch == '-'))

def write_blog(blog_title, blog_text):
    datestring = datetime.datetime.now().strftime('%Y-%m-%d')
    fname = './output/{}-{}.md'.format(datestring, sanitize_title(blog_title))
    with open(fname,'w') as f:
        f.write(blog_text)



if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--topic','-t', type=str, required=True, help='The topic to research')
    args = parser.parse_args()
    token = get_credentials()
    openai.api_key = token
    
    total_cost = 0

    idea_prompt = gen_idea_prompt(args.topic)
    idea_response = get_ideas(idea_prompt)
    idea_cost = int(idea_response['usage']['total_tokens'])
    total_cost += int(idea_cost)
    print('Used {} tokens so far'.format(total_cost))
    ideas = []
    for choice in idea_response.choices:
        choice_list = [x.split('.')[-1].strip() for x in choice['text'].strip('\n').split('\n')]
        ideas.extend(choice_list)
    print(ideas)

    for idea in ideas:
        if idea != '':
            blog_prompt = gen_chapter_prompt(args.topic, idea)
            blog = get_blog(blog_prompt)
            used = int(blog['usage']['total_tokens'])
            total_cost += used
            print('Used {} tokens so far'.format(total_cost))
            blog_text = blog.choices[0]['text']
            write_blog(idea, blog_text)
        else:
            continue
```
